package splitquery

import (
	"fmt"

	"github.com/youtube/vitess/go/sqltypes"
	"github.com/youtube/vitess/go/vt/schema"
	"github.com/youtube/vitess/go/vt/sqlparser"
	"github.com/youtube/vitess/go/vt/tabletserver/querytypes"
)

// QuerySplitter splits a BoundQuery into equally sized smaller queries.
// QuerySplits are generated by adding primary key range clauses to the
// original query. Only a limited set of queries are supported, see
// QuerySplitter.validateQuery() for details. Also, the table must have at least
// one primary key and the leading primary key must be numeric, see
// QuerySplitter.splitBoundaries()
//
// Usage example:
//
// var splitParams SplitParams
// err := splitParams.Initialize("SELECT * FROM ut_video_base",
//                               map[string]interface{}{}, ["id","user_id"], schema)
// // schema should be a map[string]schema.Table that maps a table name to its
// // schema.Table object.
// if (err != nil) {
//   return err
// }
// var splitter Splitter
// splitter.Initialize(&splitParams, &FullScanAlgorithm{}, mySqlExecuter)
// queryParts, err : = splitter.Split()
// if (err != nil) {
//   return err
// }

type SplitParams struct {
	sql           string
	bindVariables map[string]interface{}
	splitColumns  []string

	// Will contain the AST for the SELECT query (after parseAndValidateQuery is called).
	selectAST *sqlparser.Select
}

func (splitParams *SplitParams) Initialize(
	sql string,
	bindVariables map[string]interface{},
	splitColumns []string,
	schema map[string]*schema.Table) error {
	statement, err := sqlparser.Parse(sql)
	if err != nil {
		return fmt.Errorf(
			"splitter.SplitParams.Initialize(): failed parsing query: '%v', err: '%v'", sql, err)
	}
	selectAST, ok := statement.(*sqlparser.Select)
	if !ok {
		return fmt.Errorf("splitquery.SplitParams.Initialize(): not a select statement")
	}
	if selectAST.Distinct != "" || selectAST.GroupBy != nil ||
		selectAST.Having != nil || len(selectAST.From) != 1 ||
		selectAST.OrderBy != nil || selectAST.Limit != nil ||
		selectAST.Lock != "" {
		return fmt.Errorf("splitquery.SplitParams.Initialize(): unsupported query")
	}
	if len(selectAST.From) != 1 {
		return fmt.Errorf("splitquery.SplitParams.Initialize(): query must have exactly one table"+
			" in FROM clause. Got: %d", len(selectAST.From))
	}
	var aliasedTableExpr *sqlparser.AliasedTableExpr
	aliasedTableExpr, ok = selectAST.From[0].(*sqlparser.AliasedTableExpr)
	if !ok {
		return fmt.Errorf("splitquery.SplitParams.Initialize(): unsupported FROM clause in query: %v",
			sql)
	}
	tableName := sqlparser.GetTableName(aliasedTableExpr.Expr)
	if tableName == "" {
		return fmt.Errorf("splitquery.SplitParams.Initialize(): unsupported FROM clause in query"+
			" (must be a simple table expression): %v", sql)
	}
	table, ok := schema[tableName]
	if table == nil {
		return fmt.Errorf("splitquery.SplitParams.Initialize(): can't find table in schema")
	}
	// TODO(erez): Check that splitColumns are a prefix of an index.
	splitParams.sql = sql
	splitParams.bindVariables = bindVariables
	splitParams.splitColumns = splitColumns
	splitParams.selectAST = selectAST
	return nil
}

type tuple []sqltypes.Value
type SQLExecuter interface {
	SQLExecute(sql string) (*sqltypes.Result, error)
}

type splitAlgorithmInterface interface {
	initialize(splitParams *SplitParams, sqlExecuter SQLExecuter) error
	generateBoundaries() ([]tuple, error)
}

type Splitter struct {
	algorithm   splitAlgorithmInterface
	splitParams *SplitParams

	// The members below are used during the Split call.
	// They are not meant to be accessed externally.
	startBindVariableNames []string
	endBindVariableNames   []string
	firstQueryPartSQL      string
	middleQueryPartSQL     string
	lastQueryPartSQL       string
}

const (
	START_BIND_VARIABLE_PREFIX = "_splitquery_start_"
	END_BIND_VARIABLE_PREFIX   = "_splitquery_end_"
)

func (splitter *Splitter) Initialize(
	splitParams *SplitParams,
	algorithm splitAlgorithmInterface,
	sqlExecuter SQLExecuter) error {
	err := algorithm.initialize(splitParams, sqlExecuter)
	if err != nil {
		return err
	}
	splitter.splitParams = splitParams
	splitter.algorithm = algorithm
	splitter.splitParams = splitParams
	splitter.startBindVariableNames = make([]string, 0, len(splitter.splitParams.splitColumns))
	splitter.endBindVariableNames = make([]string, 0, len(splitter.splitParams.splitColumns))
	for _, splitColumn := range splitter.splitParams.splitColumns {
		splitter.startBindVariableNames = append(
			splitter.startBindVariableNames, START_BIND_VARIABLE_PREFIX+splitColumn)
		splitter.endBindVariableNames = append(
			splitter.endBindVariableNames, END_BIND_VARIABLE_PREFIX+splitColumn)
	}
	splitter.initQueryPartSQLs()
	return nil
}

func (splitter *Splitter) Split() ([]querytypes.QuerySplit, error) {
	var boundaries []tuple
	var err error
	boundaries, err = splitter.algorithm.generateBoundaries()
	if err != nil {
		return nil, err
	}
	boundaries = append(boundaries, nil)
	splits := []querytypes.QuerySplit{}
	var start tuple = nil
	for _, end := range boundaries {
		splits = append(splits, *splitter.constructQueryPart(start, end))
		start = end
	}
	return splits, nil
}

func (splitter *Splitter) initQueryPartSQLs() {
	splitColumns := convertColNamesToValExpr(splitter.splitParams.splitColumns)
	startBindVariables := convertBindVariableNamesToValExpr(splitter.startBindVariableNames)
	endBindVariables := convertBindVariableNamesToValExpr(splitter.endBindVariableNames)
	splitColsLessThanEnd := constructTupleInequality(
		splitColumns,
		endBindVariables,
		true /* strict */)
	splitColsGreaterThanOrEqualToStart := constructTupleInequality(
		startBindVariables,
		splitColumns,
		false /* not strict */)

	splitter.firstQueryPartSQL = sqlparser.String(
		queryWithAdditionalWhere(splitter.splitParams.selectAST, splitColsLessThanEnd))
	splitter.middleQueryPartSQL = sqlparser.String(
		queryWithAdditionalWhere(splitter.splitParams.selectAST,
			&sqlparser.AndExpr{
				Left:  &sqlparser.ParenBoolExpr{Expr: splitColsGreaterThanOrEqualToStart},
				Right: &sqlparser.ParenBoolExpr{Expr: splitColsLessThanEnd},
			}))
	splitter.lastQueryPartSQL = sqlparser.String(
		queryWithAdditionalWhere(splitter.splitParams.selectAST, splitColsGreaterThanOrEqualToStart))
}

func (splitter *Splitter) constructQueryPart(start, end tuple) *querytypes.QuerySplit {
	result := &querytypes.QuerySplit{}
	result.BindVariables = cloneBindVariables(splitter.splitParams.bindVariables)
	// TODO(erez): Fill result.RowCount
	if start != nil {
		populateBoundaryBindVariables(
			start, splitter.startBindVariableNames, result.BindVariables)
	}
	if end != nil {
		populateBoundaryBindVariables(
			end, splitter.endBindVariableNames, result.BindVariables)
	}
	switch {
	case start == nil && end == nil:
		// If there's no upper or lower bound then just use the original query as the query part.
		// This can happen if the boundaries list is empty.
		result.Sql = splitter.splitParams.sql
	case start == nil && end != nil:
		result.Sql = splitter.firstQueryPartSQL
	case start != nil && end != nil:
		result.Sql = splitter.middleQueryPartSQL
	case start != nil && end == nil:
		result.Sql = splitter.lastQueryPartSQL
	}
	return result
}

func populateBoundaryBindVariables(
	inputTuple tuple, bindVariableNames []string, resultBindVariables map[string]interface{}) {
	AssertEqual(len(inputTuple), len(bindVariableNames))
	for i := range inputTuple {
		_, alreadyInMap := resultBindVariables[bindVariableNames[i]]
		AssertFalse(alreadyInMap)
		resultBindVariables[bindVariableNames[i]] = inputTuple[i].ToNative()
	}
}

func convertColNamesToValExpr(colNames []string) []sqlparser.ValExpr {
	valExprs := make([]sqlparser.ValExpr, 0, len(colNames))
	for _, colName := range colNames {
		valExprs = append(valExprs, &sqlparser.ColName{Name: sqlparser.SQLName(colName)})
	}
	return valExprs
}

func convertBindVariableNamesToValExpr(bindVariableNames []string) []sqlparser.ValExpr {
	valExprs := make([]sqlparser.ValExpr, 0, len(bindVariableNames))
	for _, bindVariableName := range bindVariableNames {
		valExprs = append(valExprs, sqlparser.ValArg([]byte(":"+bindVariableName)))
	}
	return valExprs
}

func constructTupleInequality(
	lhsTuple []sqlparser.ValExpr, rhsTuple []sqlparser.ValExpr, strict bool) sqlparser.BoolExpr {
	AssertEqual(len(lhsTuple), len(rhsTuple))
	AssertGreaterOrEqual(len(lhsTuple), 1)
	if len(lhsTuple) == 1 {
		op := sqlparser.LessEqualStr
		if strict {
			op = sqlparser.LessThanStr
		}
		return &sqlparser.ComparisonExpr{
			Operator: op,
			Left:     lhsTuple[0],
			Right:    rhsTuple[0],
		}
	}
	// (lhsTuple[0] < rhsTuple[0]) OR
	// ( (lhsTuple[0] = rhsTuple[0]) AND
	//   (constructTupleInequality(lhsTuple[1:], rhsTuple[1:], strict)) )
	return &sqlparser.OrExpr{
		Left: &sqlparser.ParenBoolExpr{
			Expr: &sqlparser.ComparisonExpr{
				Operator: sqlparser.LessThanStr,
				Left:     lhsTuple[0],
				Right:    rhsTuple[0],
			}},
		Right: &sqlparser.ParenBoolExpr{
			Expr: &sqlparser.AndExpr{
				Left: &sqlparser.ParenBoolExpr{
					Expr: &sqlparser.ComparisonExpr{
						Operator: sqlparser.EqualStr,
						Left:     lhsTuple[0],
						Right:    rhsTuple[0],
					},
				},
				Right: &sqlparser.ParenBoolExpr{
					Expr: constructTupleInequality(lhsTuple[1:], rhsTuple[1:], strict),
				},
			},
		},
	}
}

func queryWithAdditionalWhere(
	selectAST *sqlparser.Select, addedWhere sqlparser.BoolExpr) *sqlparser.Select {
	result := *selectAST // Create a shallow-copy of the selectAST
	if result.Where == nil {
		result.Where = sqlparser.NewWhere(sqlparser.WhereStr, addedWhere)
	} else {
		result.Where = sqlparser.NewWhere(sqlparser.WhereStr,
			&sqlparser.AndExpr{
				Left:  &sqlparser.ParenBoolExpr{Expr: selectAST.Where.Expr},
				Right: &sqlparser.ParenBoolExpr{Expr: addedWhere},
			},
		)
	}
	return &result
}

func cloneBindVariables(bindVariables map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})
	for key, value := range bindVariables {
		result[key] = value
	}
	return result
}

// TODO(erez): Replace these with something more standard
func AssertEqual(a, b int) {
	if a != b {
		panic(fmt.Sprintf("Assertion %v == %v failed", a, b))
	}
}

func AssertFalse(a bool) {
	if a {
		panic("Condition is true. Expected false.")
	}
}

func AssertGreaterOrEqual(a, b int) {
	if a < b {
		panic(fmt.Sprintf("Assertion %v<=%v failed", a, b))
	}
}
